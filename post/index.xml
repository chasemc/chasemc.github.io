<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Academic</title>
    <link>/post/</link>
    <description>Recent content in Posts on Academic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sat, 30 Dec 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Pong</title>
      <link>/post/pong/</link>
      <pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/pong/</guid>
      <description>&lt;p&gt;I am giving a talk about Shiny soon, &lt;a href=&#34;https://chasemc.github.io/IDBac&#34;&gt;specifically an app I recently created&lt;/a&gt;, and part of this will include time for attendees to work on a Shiny app on their own or in groups. There are &lt;a href=&#34;https://shiny.rstudio.com/gallery&#34;&gt;plenty&lt;/a&gt; of sample projects for Shiny but I wanted to do something new-ish.&lt;/p&gt;
&lt;p&gt;Something I had wondered for awhile was why there weren’t many games (however simple!) written in R. After awhile of researching, two recent games seemed the best examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The best I’ve seen is &lt;a href=&#34;https://deanattali.com/blog/shiny-game-lightsout/&#34;&gt;Lights Out&lt;/a&gt; by Dean Attali, which is based in Shiny and incorporates interactivity, with pushing lights on and off within a puzzle.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The second isn’t quite a game, but made it part-way with a &lt;a href=&#34;https://www.r-bloggers.com/r-cade-games-simulating-the-legendary-game-of-pong&#34;&gt;simulation of pong&lt;/a&gt; by Peter Prevos.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I chose GGVis to keep on with my goal of getting better with tidyverse but also, and more importantly, because it was built to play well with Shiny.&lt;/p&gt;
&lt;p&gt;The first challenge is the plot itself, we prefer a blank workspace (no axes or grids). But the player will need to see boundary-lines for the top, right and bottom sides.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;shiny&amp;quot;)
library(&amp;quot;dplyr&amp;quot;)
library(&amp;quot;ggvis&amp;quot;)

boundaries &amp;lt;- tibble(x = c(0, 50, 50, 0), y = c(0, 0, 50, 50))

ggvis(x = ~x, y = ~y) %&amp;gt;% 
  layer_paths(data=boundaries) %&amp;gt;% 
  scale_numeric( &amp;quot;x&amp;quot;, domain = c(0,50)) %&amp;gt;% 
  scale_numeric( &amp;quot;y&amp;quot;, domain = c(0,50)) %&amp;gt;%
  hide_axis(scale = &amp;quot;x&amp;quot;) %&amp;gt;%
  hide_axis(scale = &amp;quot;y&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eventually we will associate the plot to a UI element via&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggvisOutput(&amp;quot;p&amp;quot;)

and 

ggvis(x = ~x, y = ~y) %&amp;gt;% 
  ... %&amp;gt;% 
   bind_shiny(&amp;quot;p&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The harder part was getting the key-bindings to work, but it’s really not so bad. There are key-bindings in GGVis, but they weren’t working all that great for the needed purpose here.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# The following code was modified based on https://stackoverflow.com/questions/24973549/r-shiny-key-input-binding
    tags$style(type=&amp;quot;text/css&amp;quot;, &amp;quot;.recalculating {opacity: 1.0;}&amp;quot;),
    tags$script(&amp;#39;$(document).on(&amp;quot;keydown&amp;quot;, function (e) {
                Shiny.onInputChange(&amp;quot;mydata&amp;quot;, [e.which, Math.random()]  );
                });&amp;#39;)  &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Math.random() above is important, as shiny will only recognize the first keystroke of the same type (down, down will only register as one down). By including Math.random() all repetitive keystrokes are returned.&lt;/p&gt;
&lt;p&gt;Then we look for the pressed key with &lt;code&gt;input$mydata&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# Update paddle position based on keyboard input  
              # Key map  
                 # left  = 37
                 # right = 39
                 # up ter   = 38
                 # down  = 40

  observeEvent(input$mydata,{
    if((is.null(input$mydata))){
      
       playerObjectInitial}else{
          
          if(input$mydata[1] == 37){
            # left arrow key is empty
          }else if(input$mydata[1] == 39){
            # right arrow key is empty
          }else if(input$mydata[1] == 38 &amp;amp;&amp;amp; max(paddleHeight$y) &amp;lt; ymax - paddleSpeed){
            paddleHeight &amp;lt;&amp;lt;- paddleHeight %&amp;gt;% mutate(y=y+paddleSpeed)
          }else if(input$mydata[1] == 40 &amp;amp;&amp;amp; min(paddleHeight$y) &amp;gt; ymin + paddleSpeed){
            paddleHeight &amp;lt;&amp;lt;-   paddleHeight %&amp;gt;% mutate(y=y-paddleSpeed)
          }
     }
  })&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
